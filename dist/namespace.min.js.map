{"version":3,"file":"namespace.min.js","sources":["../src/namespace.ts"],"sourcesContent":["type NamespacePath = string | Array<string>;\n\n/** Namespace class */\nexport default class Namespace {\n  public static attach<T>(to: T): T & Namespace {\n    let names = Object.keys(Namespace.prototype);\n    for (let name of names) {\n      (to as any)[name] = (Namespace.prototype as any)[name];\n    }\n    return to as T & Namespace;\n  }\n\n  constructor(path?: NamespacePath) {\n    if (!(this instanceof Namespace))\n      return new Namespace(path);\n    this.init(path);\n  }\n\n  protected init(path: NamespacePath | undefined) {\n    if (this.isValidPath(path)) {\n      const pathArr = this.parsePath(path as string | Array<string>);\n      const childName = pathArr.shift();\n      if (this.isValidKey(childName)) {\n        this.appendChildren(pathArr, childName as string);\n      }\n    }\n  }\n\n  private isValidPath(path: NamespacePath | undefined) {\n    return typeof path === 'string' || (Array.isArray(path) && path.length > 0);\n  }\n\n  private parsePath(path: NamespacePath): string[] {\n    return Array.isArray(path) ? path : path.split(this.getSplitter()).filter(x => this.filterName(x))\n  }\n\n  protected getSplitter() {\n    return /[\\[\\].\"']/gi;\n  }\n\n  protected filterName(name: string) {\n    return !!name && !!name.trim();\n  }\n\n  protected isValidKey(name: string | undefined): boolean {\n    return typeof name === 'string';\n  }\n\n  protected getNamespaceClass() {\n    return this instanceof Namespace ? this.constructor as typeof Namespace : Namespace;\n  }\n\n  protected take(path: NamespacePath) {\n    const isValidPath = this.isValidPath(path);\n    let context: any = this;\n    let errContext: any = undefined;\n    let exists = true;\n    let parts: string[] = [];\n    let part: string | undefined;\n\n    if (isValidPath) {\n      parts = this.parsePath(path);\n      while (parts.length > 0) {\n        part = parts.shift();\n        if (part && context[part]) {\n          context = context[part];\n        } else {\n          exists = false;\n          errContext = part ? context[part] : undefined;\n          break;\n        }\n      }\n    }\n\n    return {\n      last: context,\n      lastName: part,\n      errLast: errContext,\n      left: parts,\n      exists,\n      isValidPath\n    }\n  }\n\n  protected appendChildren(path: NamespacePath | undefined, propName: string) {\n    const nsc = this.getNamespaceClass();\n    const ns = new nsc(path);\n    ns.applyTo(this, propName as string);\n    return ns;\n  }\n\n  public applyTo(context: any, name: string): void {\n    if (!this.isValidKey(name))\n      throw new Error(`name of context is ${'' + name}`);\n    context[name] = this;\n  }\n\n  public exists(path: NamespacePath): boolean {\n    const res = this.take(path);\n    return res.exists;\n  }\n\n  public goto(path: NamespacePath): any {\n    const res = this.take(path);\n    if (res.exists) {\n      return res.last;\n    }\n    return res.errLast;\n  }\n\n  public namespace(path: NamespacePath): Namespace {\n    const res = this.take(path);\n    if (!res.exists) {\n      const last = this.appendChildren.call(res.last, res.left.slice(), res.lastName as string);\n      return last.goto(res.left) as Namespace;\n    }\n    return res.last;\n  }\n}"],"names":["path","this","Namespace","init","to","names_1","Object","keys","prototype","_i","name_1","isValidPath","pathArr","parsePath","childName","shift","isValidKey","appendChildren","Array","isArray","length","split","getSplitter","filter","x","_this","filterName","name","trim","constructor","part","context","errContext","undefined","exists","parts","last","lastName","errLast","left","propName","ns","getNamespaceClass","applyTo","Error","take","res","call","slice","goto"],"mappings":";;;;;;2BAYE,WAAYA,GACV,KAAMC,gBAAgBC,GACpB,OAAO,IAAIA,EAAUF,GACvBC,KAAKE,KAAKH,IAuGd,OAlHgBE,SAAd,SAAwBE,GAEtB,IADA,QACiBC,EADLC,OAAOC,KAAKL,EAAUM,WACjBC,WAAAA,IAAO,CAAnB,IAAIC,OACNN,EAAWM,GAASR,EAAUM,UAAkBE,IAEnD,OAAON,GASCF,iBAAV,SAAeF,GACb,GAAIC,KAAKU,YAAYX,GAAO,CAC1B,IAAMY,EAAUX,KAAKY,UAAUb,GACzBc,EAAYF,EAAQG,QACtBd,KAAKe,WAAWF,IAClBb,KAAKgB,eAAeL,EAASE,MAK3BZ,wBAAR,SAAoBF,GAClB,OAAuB,iBAATA,GAAsBkB,MAAMC,QAAQnB,IAASA,EAAKoB,OAAS,GAGnElB,sBAAR,SAAkBF,GAAlB,WACE,OAAOkB,MAAMC,QAAQnB,GAAQA,EAAOA,EAAKqB,MAAMpB,KAAKqB,eAAeC,QAAO,SAAAC,GAAK,OAAAC,EAAKC,WAAWF,OAGvFtB,wBAAV,WACE,OAAO,eAGCA,uBAAV,SAAqByB,GACnB,SAASA,KAAUA,EAAKC,QAGhB1B,uBAAV,SAAqByB,GACnB,OAAuB,iBAATA,GAGNzB,8BAAV,WACE,OAAOD,gBAAgBC,EAAYD,KAAK4B,YAAkC3B,GAGlEA,iBAAV,SAAeF,GACb,IAKI8B,EALEnB,EAAcV,KAAKU,YAAYX,GACjC+B,EAAe9B,KACf+B,OAAkBC,EAClBC,GAAS,EACTC,EAAkB,GAGtB,GAAIxB,EAEF,IADAwB,EAAQlC,KAAKY,UAAUb,GAChBmC,EAAMf,OAAS,GAAG,CAEvB,KADAU,EAAOK,EAAMpB,WACDgB,EAAQD,GAEb,CACLI,GAAS,EACTF,EAAaF,EAAOC,EAAQD,QAAQG,EACpC,MAJAF,EAAUA,EAAQD,IASxB,OAAO,CACLM,KAAML,EACNM,SAAUP,EACVQ,QAASN,EACTO,KAAMJ,EACND,SACAvB,gBAIMT,2BAAV,SAAyBF,EAAiCwC,GACxD,IACMC,EAAK,IADCxC,KAAKyC,qBACE1C,GAEnB,OADAyC,EAAGE,QAAQ1C,KAAMuC,GACVC,GAGFvC,oBAAP,SAAe6B,EAAcJ,GAC3B,IAAK1B,KAAKe,WAAWW,GACnB,MAAM,IAAIiB,MAAM,sBAA2BjB,GAC7CI,EAAQJ,GAAQ1B,OAGXC,mBAAP,SAAcF,GAEZ,OADYC,KAAK4C,KAAK7C,GACXkC,QAGNhC,iBAAP,SAAYF,GACV,IAAM8C,EAAM7C,KAAK4C,KAAK7C,GACtB,OAAI8C,EAAIZ,OACCY,EAAIV,KAENU,EAAIR,SAGNpC,sBAAP,SAAiBF,GACf,IAAM8C,EAAM7C,KAAK4C,KAAK7C,GACtB,OAAK8C,EAAIZ,OAIFY,EAAIV,KAHInC,KAAKgB,eAAe8B,KAAKD,EAAIV,KAAMU,EAAIP,KAAKS,QAASF,EAAIT,UAC1DY,KAAKH,EAAIP;;;;;;;;"}